(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{486:function(_,v,e){"use strict";e.r(v);var t=e(42),c=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[_._v("面试经常会问“为什么 TCP 要进行三次握手，四次挥手？”，这里提纲挈领的认识下这个问题。")]),_._v(" "),e("ol",[e("li",[_._v("三次握手")])]),_._v(" "),e("ul",[e("li",[_._v("第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x")]),_._v(" "),e("li",[_._v("第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y")]),_._v(" "),e("li",[_._v("第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1")])]),_._v(" "),e("p",[_._v("上面分析过程可以看出，"),e("strong",[_._v("握手两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论的")]),_._v("。")]),_._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[_._v("四次挥手")])]),_._v(" "),e("ul",[e("li",[_._v("第一次：客户端请求断开FIN")]),_._v(" "),e("li",[_._v("第二次：服务器确认客户端的断开请求ACK")]),_._v(" "),e("li",[_._v("第三次：服务器断开请求FIN")]),_._v(" "),e("li",[_._v("第四次：客户端确认服务器的断开ACK")])]),_._v(" "),e("p",[_._v("上面分析过程可以看出，"),e("strong",[_._v("客户端发送断开请求，服务端不能立马断开连接（需要将剩下报文发送完毕才可断开连接），所以会发送收到“断开连接”的请求，等服务端断开连接后告诉客户端，连接已断开，客户端确认收到服务端发送的连接断开信息后，结束这个过程。")])]),_._v(" "),e("p",[_._v("下面我们详细了解TCP到底是如何定义的。\n")]),_._v(" "),e("h2",{attrs:{id:"tcp是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp是什么"}},[_._v("#")]),_._v(" TCP是什么？")]),_._v(" "),e("p",[_._v("首先来看看 OSI 的七层模型：")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/b0d31174e498334f69a844ae09df9826",alt:"alt"}})]),_._v(" "),e("p",[_._v("我们需要知道 TCP 工作在网络 OSI 的七层模型中的第四层 —— Transport 层，IP在第三层 —— Network 层，ARP 在第二层 —— Data Link 层；在第二层上的数据，我们把它叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。\n同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。\n在 OSI 七层模型中，每一层的作用和对应的协议如下：")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/0651443ec5a3ac9801a8fba6d1c25e5b",alt:"alt"}})]),_._v(" "),e("p",[_._v("TCP 是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记 TCP 协议中每个字段的含义。")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/485f0c1b90e8dccb5a732b8ae68622ae",alt:"alt"}})]),_._v(" "),e("p",[_._v("上面就是 TCP 协议头部的格式，由于它太重要了，是理解其它内容的基础，下面就将每个字段的信息都详细的说明一下。")]),_._v(" "),e("ul",[e("li",[e("p",[e("strong",[_._v("Source Port")]),_._v(" 和 "),e("strong",[_._v("Destination Port")]),_._v(": 分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而 IP地址 是用来区分不同的主机的，源端口号 和 目的端口号 配合上IP首部中的 源IP地址 和 目的IP地址 就能唯一的确定一个 TCP 连接；")])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("Sequence Number")]),_._v(": 用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络包乱序的问题；")])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("Acknowledgment Number")]),_._v(": 32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加 1。不过，只有当标志位中的 ACK 标志（下面介绍）为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题；")])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("Offset")]),_._v(": 给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即 4*15=60个字节的首部长度），因此 TCP 最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；")])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("TCP Flags")]),_._v(": TCP 首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控 TCP 的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：")]),_._v(" "),e("ul",[e("li",[_._v("URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；")]),_._v(" "),e("li",[_._v("ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；")]),_._v(" "),e("li",[_._v("PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；")]),_._v(" "),e("li",[_._v("RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；")]),_._v(" "),e("li",[_._v("SYN：表示同步序号，用来建立连接。"),e("code",[_._v("SYN")]),_._v("标志位和"),e("code",[_._v("ACK")]),_._v("标志位搭配使用，当连接请求的时候，"),e("code",[_._v("SYN")]),_._v("=1，"),e("code",[_._v("ACK")]),_._v("=0；连接被响应的时候，"),e("code",[_._v("SYN")]),_._v("=1，"),e("code",[_._v("ACK")]),_._v("=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有"),e("code",[_._v("SYN")]),_._v("的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；")]),_._v(" "),e("li",[_._v("FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送"),e("code",[_._v("FIN")]),_._v("标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。")])])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("Window")]),_._v(":窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的；")])])]),_._v(" "),e("p",[_._v("好了，基本知识都已经准备好了，开始下一段的征程吧。")]),_._v(" "),e("h2",{attrs:{id:"三次握手又是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手又是什么"}},[_._v("#")]),_._v(" 三次握手又是什么？")]),_._v(" "),e("p",[_._v("TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小信息。这就是面试中经常会被问到的"),e("strong",[_._v("TCP三次握手")]),_._v("。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/40d8a82c1fcd268c259ef9a0f5fba57f",alt:"alt"}})]),_._v(" "),e("p",[_._v("多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。")]),_._v(" "),e("ol",[e("li",[_._v("第一次握手：建立连接。客户端发送连接请求报文段，将"),e("code",[_._v("SYN")]),_._v("位置为1，"),e("code",[_._v("Sequence Number")]),_._v("为x；然后，客户端进入"),e("code",[_._v("SYN_SEND")]),_._v("状态，等待服务器的确认；")]),_._v(" "),e("li",[_._v("第二次握手：服务器收到"),e("code",[_._v("SYN")]),_._v("报文段。服务器收到客户端的"),e("code",[_._v("SYN")]),_._v("报文段，需要对这个"),e("code",[_._v("SYN")]),_._v("报文段进行确认，设置"),e("code",[_._v("Acknowledgment Number")]),_._v("为x+1("),e("code",[_._v("Sequence Number")]),_._v("+1)；同时，自己自己还要发送"),e("code",[_._v("SYN")]),_._v("请求信息，将"),e("code",[_._v("SYN")]),_._v("位置为1，"),e("code",[_._v("Sequence Number")]),_._v("为y；服务器端将上述所有信息放到一个报文段（即"),e("code",[_._v("SYN+ACK")]),_._v("报文段）中，一并发送给客户端，此时服务器进入"),e("code",[_._v("SYN_RECV")]),_._v("状态；")]),_._v(" "),e("li",[_._v("第三次握手：客户端收到服务器的"),e("code",[_._v("SYN+ACK")]),_._v("报文段。然后将"),e("code",[_._v("Acknowledgment Number")]),_._v("设置为y+1，向服务器发送"),e("code",[_._v("ACK")]),_._v("报文段，这个报文段发送完毕以后，客户端和服务器端都进入"),e("code",[_._v("ESTABLISHED")]),_._v("状态，完成TCP三次握手。")])]),_._v(" "),e("p",[_._v("完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。")]),_._v(" "),e("h2",{attrs:{id:"那四次分手呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那四次分手呢"}},[_._v("#")]),_._v(" 那四次分手呢？")]),_._v(" "),e("p",[_._v("当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。")]),_._v(" "),e("ol",[e("li",[_._v("第一次分手：主机1（可以使客户端，也可以是服务器端），设置"),e("code",[_._v("Sequence Number")]),_._v("和"),e("code",[_._v("Acknowledgment Number")]),_._v("，向主机2发送一个"),e("code",[_._v("FIN")]),_._v("报文段；此时，主机1进入"),e("code",[_._v("FIN_WAIT_1")]),_._v("状态；这表示主机1没有数据要发送给主机2了；")]),_._v(" "),e("li",[_._v("第二次分手：主机2收到了主机1发送的"),e("code",[_._v("FIN")]),_._v("报文段，向主机1回一个"),e("code",[_._v("ACK")]),_._v("报文段，"),e("code",[_._v("Acknowledgment Number")]),_._v("为"),e("code",[_._v("Sequence Number")]),_._v("加1；主机1进入"),e("code",[_._v("FIN_WAIT_2")]),_._v("状态；主机2告诉主机1，我已经知道你没有数据要发送了；")]),_._v(" "),e("li",[_._v("第三次分手：主机2向主机1发送"),e("code",[_._v("FIN")]),_._v("报文段，请求关闭连接，同时主机2进入"),e("code",[_._v("CLOSE_WAIT")]),_._v("状态；")]),_._v(" "),e("li",[_._v("第四次分手：主机1收到主机2发送的"),e("code",[_._v("FIN")]),_._v("报文段，向主机2发送"),e("code",[_._v("ACK")]),_._v("报文段，然后主机1进入"),e("code",[_._v("TIME_WAIT")]),_._v("状态；主机2收到主机1的"),e("code",[_._v("ACK")]),_._v("报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。")])]),_._v(" "),e("p",[_._v("至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。")]),_._v(" "),e("h2",{attrs:{id:"为什么要三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要三次握手"}},[_._v("#")]),_._v(" 为什么要三次握手")]),_._v(" "),e("p",[_._v("既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：")]),_._v(" "),e("blockquote",[e("p",[_._v("为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。")])]),_._v(" "),e("p",[_._v("在书中同时举了一个例子，如下：")]),_._v(" "),e("blockquote",[e("p",[_._v("“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”")])]),_._v(" "),e("p",[_._v("这就很明白了，防止了服务器端的一直等待而浪费资源。")]),_._v(" "),e("h2",{attrs:{id:"为什么要四次分手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要四次分手"}},[_._v("#")]),_._v(" 为什么要四次分手")]),_._v(" "),e("p",[_._v("那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出"),e("code",[_._v("FIN")]),_._v("报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回"),e("code",[_._v("ACK")]),_._v("报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了"),e("code",[_._v("FIN")]),_._v("报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("FIN_WAIT_1")]),_._v(": 这个状态要好好解释一下，其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是： FIN_WAIT_1 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 即进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。（主动方）")]),_._v(" "),e("li",[e("strong",[_._v("FIN_WAIT_2")]),_._v("：上面已经详细解释了这种状态，实际上 FIN_WAIT_2 状态下的 SOCKET，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你( ACK 信息)，稍后再关闭连接。（主动方）")]),_._v(" "),e("li",[e("strong",[_._v("CLOSE_WAIT")]),_._v("：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以  close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。（被动方）")]),_._v(" "),e("li",[e("strong",[_._v("LAST_ACK")]),_._v(": 这个状态还是比较容易好理解的，它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态了。（被动方）")]),_._v(" "),e("li",[e("strong",[_._v("TIME_WAIT")]),_._v(": 表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。（主动方）")]),_._v(" "),e("li",[e("strong",[_._v("CLOSED")]),_._v(": 表示连接中断。")])])])}),[],!1,null,null,null);v.default=c.exports}}]);