(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{542:function(v,_,e){"use strict";e.r(_);var t=e(42),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("树，有二叉树、二叉查找树、平衡树、平衡二叉树、红黑树等等。本文分别罗列每种树的原理及使用案例，深入了解『树』这一数据结构\n")]),v._v(" "),e("h2",{attrs:{id:"一、树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、树"}},[v._v("#")]),v._v(" 一、树")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("定义")]),v._v(" "),e("p",[v._v("树（树状图）是一种"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450",target:"_blank",rel:"noopener noreferrer"}},[v._v("数据结构"),e("OutboundLink")],1),v._v("，它是由n（n>=1）个有限结点组成一个具有层次关系的"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E9%9B%86%E5%90%88",target:"_blank",rel:"noopener noreferrer"}},[v._v("集合"),e("OutboundLink")],1),v._v("。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。")])]),v._v(" "),e("li",[e("p",[v._v("特点：")]),v._v(" "),e("ol",[e("li",[v._v("每个结点有零个或多个子结点；")]),v._v(" "),e("li",[v._v("没有父结点的结点称为根结点；")]),v._v(" "),e("li",[v._v("每一个非根结点有且只有一个父结点；")]),v._v(" "),e("li",[v._v("除了根结点外，每个子结点可以分为多个不相交的子树；")])])])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/766076c5287cd60542a84b16a0b2dcff",alt:"树的示意图"}})]),v._v(" "),e("h2",{attrs:{id:"二、二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、二叉树"}},[v._v("#")]),v._v(" 二、二叉树")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("定义")]),v._v(" "),e("p",[v._v("二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。")])]),v._v(" "),e("li",[e("p",[v._v("满二叉树和完全二叉树")]),v._v(" "),e("ul",[e("li",[v._v("满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。")]),v._v(" "),e("li",[v._v("完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。")])])])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/d0c6bce98a86a4852f7629f18733f69e",alt:"满二叉树和完全二叉树示意图"}})]),v._v(" "),e("h2",{attrs:{id:"三、二叉查找树-二叉搜索树-二叉排序树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、二叉查找树-二叉搜索树-二叉排序树"}},[v._v("#")]),v._v(" 三、二叉查找树（二叉搜索树，二叉排序树）")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("定义")]),v._v(" "),e("p",[v._v("二叉查找树又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：")]),v._v(" "),e("p",[v._v("1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；")]),v._v(" "),e("p",[v._v("2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；")]),v._v(" "),e("p",[v._v("3) 左、右子树也分别为二叉排序树；")]),v._v(" "),e("p",[v._v("4) 没有键值相等的节点。")])]),v._v(" "),e("li",[e("p",[v._v("性质")]),v._v(" "),e("p",[v._v("对二叉查找树进行中序遍历，即可得到有序的数列。它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。"),e("strong",[v._v("二叉查找树的高度决定了二叉查找树的查找效率。")])])])]),v._v(" "),e("h2",{attrs:{id:"四、平衡二叉树-avl树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、平衡二叉树-avl树"}},[v._v("#")]),v._v(" 四、平衡二叉树（AVL树）")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("定义")]),v._v(" "),e("p",[v._v("平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。")]),v._v(" "),e("p",[v._v("最小二叉平衡树的节点的公式如下：")]),v._v(" "),e("ul",[e("li",[v._v("F(n)=F(n-1)+F(n-2)+1")])]),v._v(" "),e("p",[v._v("这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/742b7752cc7e49103ab0756964819fc3",alt:"img"}})]),v._v(" "),e("p",[e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/9cd732ab9b1d99d7e0b0fcad89fc526a",alt:"img"}})])]),v._v(" "),e("li",[e("p",[v._v("AVL树")])])]),v._v(" "),e("h2",{attrs:{id:"六、红黑树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、红黑树"}},[v._v("#")]),v._v(" 六、红黑树：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("变换操作：")]),v._v(" "),e("ol",[e("li",[v._v("变色： 黑 -> 红， 红 -> 黑")]),v._v(" "),e("li",[v._v("左旋：  "),e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/bdac1717c96f72e37e69ce233bc09636",alt:"这里写图片描述"}})]),v._v(" "),e("li",[v._v("右旋： "),e("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/b227741dcb6d60dd90d1d69c73fe3573",alt:"这里写图片描述"}})])])]),v._v(" "),e("li",[e("p",[v._v("变换规则：\n旋转和颜色变化规则： 所有插入点默认为红色")]),v._v(" "),e("ol",[e("li",[v._v("变颜色的情况：当前结点的父亲是红色，且它的祖父结点的另一个子结点（即叔叔结点）也是红色：\n"),e("ol",[e("li",[v._v("把父结点设为黑色；")]),v._v(" "),e("li",[v._v("把叔叔结点也设为黑色；")]),v._v(" "),e("li",[v._v("把祖父结点设为红色；")]),v._v(" "),e("li",[v._v("把当前要操作的指针定义到祖父结点；")]),v._v(" "),e("li",[v._v("分析祖父结点变换规则；")])])]),v._v(" "),e("li",[v._v("左旋： 当前父结点是红色，叔叔是黑色，且当前结点是右子树时，以父结点为根进行左旋")]),v._v(" "),e("li",[v._v("右旋： 当前父结点是红色，叔叔是黑色，且当前结点是左子树时：\n"),e("ol",[e("li",[v._v("把父结点变为黑色；")]),v._v(" "),e("li",[v._v("把祖父结点变为红色；")]),v._v(" "),e("li",[v._v("以祖父结点作为根进行右旋；")])])])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);