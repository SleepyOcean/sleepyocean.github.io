(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{536:function(t,e,r){"use strict";r.r(e);var a=r(42),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"java中io流的体系结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java中io流的体系结构"}},[t._v("#")]),t._v(" Java中IO流的体系结构")]),t._v(" "),r("p",[r("strong",[t._v("节点流")]),t._v("：程序直接连接到实际的数据源，进行读写。")]),t._v(" "),r("p",[r("strong",[t._v("处理流")]),t._v("：又称高级流或包装流，处理流对一个已存在的流进行连接，通过封装后的流来进行读写。\n")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/92040388841b440c2c0eb1883beb91bd",alt:"Java-IO-3"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/80a60e47cda3f0434ea6d9d61646405d",alt:"Java-IO-2"}})]),t._v(" "),r("h2",{attrs:{id:"_1-字节流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-字节流"}},[t._v("#")]),t._v(" 1. 字节流")]),t._v(" "),r("p",[r("strong",[t._v("InputStream中的三个基本的读方法")]),t._v(" "),r("code",[t._v("abstract int read()")]),t._v("：读取一个字节数据，并返回读到的数据，如果返回-1，表示读到了输入流的末尾。\n"),r("code",[t._v("int read(byte[] b)")]),t._v("：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。\n"),r("code",[t._v("int read(byte[] b, int off, int len)")]),t._v("：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。off指定在数组b中存放数据的起始偏移位置；len指定读取的最大字节数。")]),t._v(" "),r("p",[t._v("流结束的判断：方法read()的返回值为-1时；readLine()的返回值为null时。")]),t._v(" "),r("p",[r("strong",[t._v("outputStream中的三个基本的写方法")]),t._v(" "),r("code",[t._v("abstract void write(int b)")]),t._v("：往输出流中写入一个字节。\n"),r("code",[t._v("void write(byte[] b)")]),t._v("：往输出流中写入数组b中的所有字节。\n"),r("code",[t._v("void write(byte[] b, int off, int len)")]),t._v(" ：往输出流中写入数组b中从偏移量off开始的len个字节的数据。")]),t._v(" "),r("p",[t._v("其它方法\n"),r("code",[t._v("void flush()")]),t._v(" ：刷新输出流，强制缓冲区中的输出字节被写出。\n"),r("code",[t._v("void close()")]),t._v(" ：关闭输出流，释放和这个流相关的系统资源。")]),t._v(" "),r("h2",{attrs:{id:"_2-字符流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-字符流"}},[t._v("#")]),t._v(" 2. 字符流")]),t._v(" "),r("p",[r("strong",[t._v("字符流的由来：")]),t._v(" Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。")]),t._v(" "),r("p",[r("strong",[t._v("字符输入流Reader主要方法")])]),t._v(" "),r("p",[r("code",[t._v("int read()")]),t._v("： 读取一个字符，返回值为读取的字符\n"),r("code",[t._v("int read(char cbuf[])")]),t._v("： 读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量\n"),r("code",[t._v("abstract int read(char cbuf[],int off,int len)")]),t._v("： 读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现")]),t._v(" "),r("p",[r("strong",[t._v("字符输出流Writer主要方法")])]),t._v(" "),r("p",[r("code",[t._v("void write(int c)")]),t._v("：将整型值c的低16位写入输出流\n"),r("code",[t._v("void write(char cbuf[])")]),t._v("：将字符数组cbuf[]写入输出流\n"),r("code",[t._v("abstract void write(char cbuf[],int off,int len)")]),t._v("：将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流\n"),r("code",[t._v("void write(String str)")]),t._v("：将字符串str中的字符写入输出流\n"),r("code",[t._v("void write(String str,int off,int len)")]),t._v("：将字符串str 中从索引off开始处的len个字符写入输出流")]),t._v(" "),r("h2",{attrs:{id:"字节流和字符流的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字节流和字符流的区别"}},[t._v("#")]),t._v(" 字节流和字符流的区别")]),t._v(" "),r("p",[t._v("字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。")]),t._v(" "),r("p",[t._v("读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。")]),t._v(" "),r("p",[t._v("处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。")]),t._v(" "),r("p",[r("strong",[t._v("结论")]),t._v("：只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/decb44a9f16294f3eb425bba94427d7c",alt:"image"}})]),t._v(" "),r("h2",{attrs:{id:"各种流的应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#各种流的应用场景"}},[t._v("#")]),t._v(" 各种流的应用场景")]),t._v(" "),r("ul",[r("li",[t._v("FileInputStream/FileOutputStream  需要逐个字节处理原始二进制流的时候使用，效率低下。")]),t._v(" "),r("li",[t._v("FileReader/FileWriter 需要组个字符处理的时候使用。")]),t._v(" "),r("li",[t._v("StringReader/StringWriter 需要处理字符串的时候，可以将字符串保存为字符数组。")]),t._v(" "),r("li",[t._v("PrintStream/PrintWriter 用来包装FileOutputStream 对象，方便直接将String字符串写入文件 。")]),t._v(" "),r("li",[t._v("Scanner　用来包装System.in流，很方便地将输入的String字符串转换成需要的数据类型。")]),t._v(" "),r("li",[t._v("InputStreamReader/OutputStreamReader ,  字节和字符的转换桥梁，在网络通信或者处理键盘输入的时候用。")]),t._v(" "),r("li",[t._v("BufferedReader/BufferedWriter， BufferedInputStream/BufferedOutputStream  缓冲流用来包装字节流后者字符流，提升IO性能\n"),r("ul",[r("li",[t._v("BufferedReader还可以方便地读取一行，简化编程。")]),t._v(" "),r("li",[t._v("SequenceInputStream(InputStream s1, InputStream s2)序列流，合并流对象时使用.")]),t._v(" "),r("li",[t._v("ObjectInputStream、ObjectOutputStream，方法用于序列化对象并将它们写入一个流，另一个方法用于读取流并反序列化对象。")])])]),t._v(" "),r("li",[t._v("ByteArrayInputStream、ByteArrayOutputStream 操作数组")]),t._v(" "),r("li",[t._v("DataInputStream、DataOutputStream操作基本数据类型和字符串。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);