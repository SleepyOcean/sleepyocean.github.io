(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{509:function(e,r,t){"use strict";t.r(r);var o=t(42),n=Object(o.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("云原生是一种行为方式和设计理念，如今它正在遭受过度地市场化包装。究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。—— "),t("a",{attrs:{href:"https://jimmysong.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Jimmy Song"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括 "),t("strong",[e._v("容器")]),e._v("、"),t("strong",[e._v("服务网格")]),e._v("、"),t("strong",[e._v("微服务")]),e._v("、"),t("strong",[e._v("不可变基础设施")]),e._v(" 和 "),t("strong",[e._v("声明式 API")]),e._v("。这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。——CNCF（云原生计算基金会）。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://gallery.sleepyocean.cn/resource/img/e460ebe23cf6f76bfa4ccabb25bb19e4",alt:"云原生知识图谱"}})]),e._v(" "),t("h2",{attrs:{id:"一、容器和容器化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、容器和容器化"}},[e._v("#")]),e._v(" 一、容器和容器化")]),e._v(" "),t("p",[t("strong",[t("u",[e._v("演进")])]),e._v("： 虚拟机 -> 容器")]),e._v(" "),t("p",[t("strong",[t("u",[e._v("容器")])]),e._v("： 可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。")]),e._v(" "),t("p",[t("strong",[t("u",[e._v("容器化工具")])]),e._v("： Docker、 "),t("a",{attrs:{href:"https://coreos.com/rkt/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CoreOS rkt"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://mesos.apache.org/documentation/latest/mesos-containerizer/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mesos Containerizer"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"https://linuxcontainers.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("LXC"),t("OutboundLink")],1),e._v("。目前绝大多数的容器化应用都是在 Docker 上运行的。")]),e._v(" "),t("p",[t("strong",[t("u",[e._v("Kubernetes")])]),e._v("： 编排管理监控容器的调度平台")]),e._v(" "),t("h2",{attrs:{id:"二、kubernetes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、kubernetes"}},[e._v("#")]),e._v(" 二、Kubernetes")]),e._v(" "),t("h3",{attrs:{id:"_1-kubernetes架构中的组件解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-kubernetes架构中的组件解释"}},[e._v("#")]),e._v(" 1）Kubernetes架构中的组件解释")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[t("u",[e._v("namespace")])]),e._v("： 虚拟集群")])]),e._v(" "),t("li",[t("p",[t("strong",[t("u",[e._v("node")])]),e._v("： 集群中的单个机器（物理机或虚拟机），部署应用或服务的地方。有里那个猴子那个类型——master节点和worker节点（主从结构）。")]),e._v(" "),t("ul",[t("li",[t("strong",[t("u",[e._v("Master节点")])]),e._v("： 一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。")]),e._v(" "),t("li",[t("strong",[t("u",[e._v("Woker 节点")])]),e._v("： 是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。")])])]),e._v(" "),t("li",[t("p",[t("strong",[t("u",[e._v("pod")])]),e._v("： 是Kubernetes中的逻辑而非物理的工作单位。一个pod通常包含一个活多个Docker容器，把这些容器作为一个独立单元来管理。")])]),e._v(" "),t("li",[t("p",[t("strong",[t("u",[e._v("service")])]),e._v("： 是Kubernetes中的一组逻辑上的pod。service提供了一个单一的IP地址和DNS名称，你可以通过它访问服务内的所有pod。")])]),e._v(" "),t("li",[t("p",[t("strong",[t("u",[e._v("ReplicationController 或 ReplicaSet")])]),e._v("： 是Kubernetes中负责实际管理pod生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。")])])]),e._v(" "),t("p",[t("strong",[t("u",[e._v("Kubectl")])]),e._v("： 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。")]),e._v(" "),t("h3",{attrs:{id:"_2-kubernetes网络相关解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-kubernetes网络相关解释"}},[e._v("#")]),e._v(" 2）Kubernetes网络相关解释")]),e._v(" "),t("p",[e._v("a. "),t("strong",[t("u",[e._v("Kubernetes的Ingress和Egress")])])]),e._v(" "),t("p",[e._v("外部用户或应用程序与 Kubernetes pod 交互时为托管应用服务定义安全规则。")]),e._v(" "),t("p",[e._v("其中，进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 Egress。")]),e._v(" "),t("p",[e._v("我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。")]),e._v(" "),t("p",[e._v("b. "),t("strong",[t("u",[e._v("Ingress Controller")])])]),e._v(" "),t("p",[e._v("在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。")]),e._v(" "),t("p",[e._v("c. "),t("strong",[t("u",[e._v("Replica和ReplicaSet")])])]),e._v(" "),t("p",[e._v("为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。")]),e._v(" "),t("p",[e._v("所需状态是在 deployment 中定义的。 Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。")]),e._v(" "),t("p",[e._v("因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。")]),e._v(" "),t("p",[e._v("d. "),t("strong",[t("u",[e._v("Service Mesh")])])]),e._v(" "),t("p",[e._v("服务网格 (Service Mesh) 用于管理服务之间的网络流量。")]),e._v(" "),t("p",[e._v("服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。")]),e._v(" "),t("p",[e._v("所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。")]),e._v(" "),t("p",[e._v("如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。")])])}),[],!1,null,null,null);r.default=n.exports}}]);